# -*- coding: utf-8 -*-
"""mlprojectfinal.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1XqE1BC_3riJBzsHood0uqXXUV7H0hNLz
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import random
from sklearn.model_selection import train_test_split, GridSearchCV, cross_val_score
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, roc_curve, auc, precision_recall_curve, average_precision_score, classification_report
from imblearn.over_sampling import SMOTE
import xgboost as xgb
import shap

# Data Generation Function
def generate_human_like_data(num_samples=5000, seed=42):
    np.random.seed(seed)
    random.seed(seed)

    data = []
    for _ in range(num_samples):
        battery_drain = max(5, int(np.random.normal(loc=60, scale=20)))
        overheating = random.choices(["Yes", "No"], weights=[0.7 if battery_drain < 30 else 0.3, 0.7])[0]
        unknown_apps = random.choices(["Yes", "No"], weights=[0.25, 0.75])[0]  # Increased "Yes" probability
        data_usage = random.choices(["Low", "Medium", "High"], weights=[0.3, 0.5, 0.2])[0]
        unauthorized_access = random.choices(["Yes", "No"], weights=[0.15, 0.85])[0]  # Increased "Yes" probability
        app_crashes = random.choices(["Yes", "No"], weights=[0.3, 0.7])[0]  # Increased "Yes" probability

        # New feature: Interaction term
        severe_symptoms = 1 if (overheating == "Yes" and app_crashes == "Yes") else 0

        score = 0
        if battery_drain < 25: score += 1
        if overheating == "Yes": score += 1
        if unknown_apps == "Yes": score += 1
        if data_usage == "High": score += 1
        if unauthorized_access == "Yes": score += 2
        if app_crashes == "Yes": score += 1
        if severe_symptoms == 1: score += 1

        # Lowered threshold from 4 to 3 to generate more "Hacked" instances
        is_hacked = 1 if score >= 3 else 0
        if random.random() < 0.05:  # Noise
            is_hacked = 1 - is_hacked

        data.append({
            "Battery_Drain": battery_drain,
            "Overheating": overheating,
            "Unknown_Apps": unknown_apps,
            "Data_Usage": data_usage,
            "Unauthorized_Access": unauthorized_access,
            "App_Crashes": app_crashes,
            "Severe_Symptoms": severe_symptoms,
            "Is_Hacked": is_hacked
        })

    return pd.DataFrame(data)

# Generate and save dataset
df = generate_human_like_data(5000)
df.to_csv("phone_hack_dataset_enhanced.csv", index=False)
print("‚úÖ Enhanced dataset saved as phone_hack_dataset_enhanced.csv")

"""#Data Preprocessing and Model Training"""

# Load and preprocess data
df = pd.read_csv("phone_hack_dataset_enhanced.csv")
X = df.drop("Is_Hacked", axis=1)
y = df["Is_Hacked"]

# Encode categorical columns
encoders = {}
for col in X.columns:
    if X[col].dtype == "object":
        le = LabelEncoder()
        X[col] = le.fit_transform(X[col])
        encoders[col] = le

feature_order = X.columns.tolist()

# Train/test split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, stratify=y, random_state=42)

# Apply SMOTE
smote = SMOTE(random_state=42)
X_train_resampled, y_train_resampled = smote.fit_resample(X_train, y_train)

# Hyperparameter tuning for RandomForest
param_grid_rf = {
    'n_estimators': [100, 150, 200],
    'max_depth': [5, 10, 15],
    'min_samples_split': [2, 5, 10]
}
rf = RandomForestClassifier(random_state=42, class_weight='balanced')
grid_search_rf = GridSearchCV(rf, param_grid_rf, cv=5, scoring='f1', n_jobs=-1)
grid_search_rf.fit(X_train_resampled, y_train_resampled)
rf_model = grid_search_rf.best_estimator_
print(f"Best RF parameters: {grid_search_rf.best_params_}")

# Hyperparameter tuning for XGBoost
param_grid_xgb = {
    'n_estimators': [100, 150, 200],
    'max_depth': [3, 5, 7],
    'learning_rate': [0.01, 0.1, 0.2]
}
xgb_model = xgb.XGBClassifier(random_state=42, scale_pos_weight=len(y_train[y_train == 0]) / len(y_train[y_train == 1]))
grid_search_xgb = GridSearchCV(xgb_model, param_grid_xgb, cv=5, scoring='f1', n_jobs=-1)
grid_search_xgb.fit(X_train_resampled, y_train_resampled)
xgb_model = grid_search_xgb.best_estimator_
print(f"Best XGBoost parameters: {grid_search_xgb.best_params_}")

# Cross-validation scores
cv_scores_rf = cross_val_score(rf_model, X_train_resampled, y_train_resampled, cv=5, scoring='f1')
cv_scores_xgb = cross_val_score(xgb_model, X_train_resampled, y_train_resampled, cv=5, scoring='f1')
print(f"RF Cross-validation F1 scores: {cv_scores_rf.mean():.2f} (¬±{cv_scores_rf.std():.2f})")
print(f"XGBoost Cross-validation F1 scores: {cv_scores_xgb.mean():.2f} (¬±{cv_scores_xgb.std():.2f})")

"""#User Input and Prediction"""

# User Input with Validation
def get_valid_input(prompt, valid_options, input_type=str):
    while True:
        try:
            value = input_type(input(prompt))
            if input_type == int and (value < 0 or value > 100):
                print("Please enter a percentage between 0 and 100.")
            elif input_type == str and value.capitalize() not in valid_options:
                print(f"Please enter one of: {', '.join(valid_options)}")
            else:
                return value.capitalize() if input_type == str else value
        except ValueError:
            print("Invalid input. Please try again.")

print("\nüì± Phone Hack Risk Assessment Tool üì±\n")
print("Please answer the following questions about your phone's behavior:\n")

user_data = {
    "Battery_Drain": get_valid_input("Battery Drain Percentage (e.g., 85): ", [], int),
    "Overheating": get_valid_input("Is the phone overheating? (Yes/No): ", ["Yes", "No"]),
    "Unknown_Apps": get_valid_input("Are there unknown apps installed? (Yes/No): ", ["Yes", "No"]),
    "Data_Usage": get_valid_input("Data usage level? (Low/Medium/High): ", ["Low", "Medium", "High"]),
    "Unauthorized_Access": get_valid_input("Any unauthorized access detected? (Yes/No): ", ["Yes", "No"]),
    "App_Crashes": get_valid_input("Do apps crash frequently? (Yes/No): ", ["Yes", "No"])
}
user_data["Severe_Symptoms"] = 1 if (user_data["Overheating"] == "Yes" and user_data["App_Crashes"] == "Yes") else 0

# Create DataFrame
user_df = pd.DataFrame([user_data])
for col in user_df.columns:
    if col in encoders:
        user_df[col] = encoders[col].transform(user_df[col])

user_df = user_df[feature_order]

# Predict with both models and tune threshold
thresholds = [0.2, 0.3, 0.4, 0.5, 0.6, 0.7]
best_f1 = 0
best_threshold = 0.5

# Evaluate on test set to find optimal threshold (using RF as example)
from sklearn.metrics import f1_score # Importing f1_score
y_test_prob_rf = rf_model.predict_proba(X_test)[:, 1]
for thresh in thresholds:
    y_pred_test = (y_test_prob_rf >= thresh).astype(int)
    f1 = f1_score(y_test, y_pred_test)
    if f1 > best_f1:
        best_f1 = f1
        best_threshold = thresh
print(f"Optimal threshold based on F1: {best_threshold} with F1 score: {best_f1:.2f}")

# User prediction
rf_prob = rf_model.predict_proba(user_df)[0][1]
xgb_prob = xgb_model.predict_proba(user_df)[0][1]
rf_pred = int(rf_prob >= best_threshold)
xgb_pred = int(xgb_prob >= best_threshold)

print("\nüîç Analysis Complete!")
print(f"RF Model - Risk score: {rf_prob * 100:.2f}%, Prediction: {'üö®Your phone is likely HACKED!' if rf_pred == 1 else '‚úÖ Your phone seems safe'}")
print(f"XGBoost Model - Risk score: {xgb_prob * 100:.2f}%, Prediction: {'üö®Your phone is likely HACKED!' if xgb_pred == 1 else '‚úÖ Your phone seems safe'}")

# SHAP explanation for RF
explainer_rf = shap.TreeExplainer(rf_model)
shap_values_rf = explainer_rf.shap_values(user_df)
if isinstance(shap_values_rf, list) and len(shap_values_rf) == 2:
    shap_positive_rf = shap_values_rf[1]
else:
    shap_positive_rf = shap_values_rf
# SHAP explanation for XGBoost
explainer_xgb = shap.TreeExplainer(xgb_model)
shap_values_xgb = explainer_xgb.shap_values(user_df)
if isinstance(shap_values_xgb, list) and len(shap_values_xgb) == 2:
    shap_positive_xgb = shap_values_xgb[1]
else:
    shap_positive_xgb = shap_values_xgb

"""#Visualization and Performance Metrics"""

from sklearn.metrics import f1_score

fig, axs = plt.subplots(2, 3, figsize=(20, 10))
fig.suptitle("üìä Machine Learning Hack Detection Insights", fontsize=16)

importances_rf = rf_model.feature_importances_
indices_rf = np.argsort(importances_rf)[::-1]
axs[0, 0].bar(range(len(feature_order)), importances_rf[indices_rf], color="royalblue")
axs[0, 0].set_xticks(range(len(feature_order)))
axs[0, 0].set_xticklabels([feature_order[i] for i in indices_rf], rotation=45)
axs[0, 0].set_title("RF Feature Importance")
axs[0, 0].grid(True)

y_pred_rf = rf_model.predict(X_test)
cm_rf = confusion_matrix(y_test, y_pred_rf)
disp_rf = ConfusionMatrixDisplay(confusion_matrix=cm_rf, display_labels=["Safe", "Hacked"])
disp_rf.plot(ax=axs[0, 1], cmap="Blues", colorbar=False)
axs[0, 1].set_title("RF Confusion Matrix")

y_proba_rf = rf_model.predict_proba(X_test)[:, 1]
fpr_rf, tpr_rf, _ = roc_curve(y_test, y_proba_rf)
roc_auc_rf = auc(fpr_rf, tpr_rf)
axs[0, 2].plot(fpr_rf, tpr_rf, color="darkorange", lw=2, label=f"RF AUC = {roc_auc_rf:.2f}")
axs[0, 2].plot([0, 1], [0, 1], color="navy", lw=2, linestyle="--")
axs[0, 2].set_title("ROC Curve (RF)")
axs[0, 2].legend()
axs[0, 2].grid(True)

precision_rf, recall_rf, thresholds_pr = precision_recall_curve(y_test, y_proba_rf)
avg_precision_rf = average_precision_score(y_test, y_proba_rf)
axs[1, 0].plot(recall_rf, precision_rf, color="green", lw=2, label=f"RF Avg Precision = {avg_precision_rf:.2f}")
axs[1, 0].set_title("Precision-Recall Curve (RF)")
axs[1, 0].legend()
axs[1, 0].grid(True)

risk_scores_rf = rf_model.predict_proba(X_test)[:, 1]
axs[1, 1].hist(risk_scores_rf, bins=20, color="purple", alpha=0.7)
axs[1, 1].axvline(x=best_threshold, color="red", linestyle="--", label=f"Threshold = {best_threshold}")
axs[1, 1].set_title("RF Risk Score Distribution")
axs[1, 1].legend()
axs[1, 1].grid(True)

visual = user_df.copy()
for col in visual.columns:
    if col in encoders:
        visual[col] = encoders[col].inverse_transform(visual[col])

axs[1, 2].bar(visual.columns, [1 if str(val).lower() in ["yes", "high"] else 0 for val in visual.iloc[0]], color="crimson")
axs[1, 2].set_title("‚ö†Ô∏è User Reported Symptoms")
axs[1, 2].set_xticklabels(visual.columns, rotation=45)
axs[1, 2].set_ylim(0, 1.5)
axs[1, 2].grid(True)

plt.tight_layout(rect=[0, 0.03, 1, 0.95])
plt.show()

print("\nDetailed Performance Metrics (RF):")
print(classification_report(y_test, y_pred_rf, target_names=["Safe", "Hacked"]))

y_pred_xgb = xgb_model.predict(X_test)
print("\nDetailed Performance Metrics (XGBoost):")
print(classification_report(y_test, y_pred_xgb, target_names=["Safe", "Hacked"]))